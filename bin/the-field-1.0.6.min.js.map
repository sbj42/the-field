{"version":3,"sources":["webpack://TheField/./src/field-of-view.ts","webpack://TheField/./src/geom/index.ts","webpack://TheField/./src/geom/mask-rect.ts","webpack://TheField/./src/geom/mask.ts","webpack://TheField/./src/geom/offset.ts","webpack://TheField/./src/geom/rectangle.ts","webpack://TheField/./src/geom/size.ts","webpack://TheField/./src/index.ts","webpack://TheField/webpack/bootstrap","webpack://TheField/webpack/startup"],"names":["BODY_EPSILON","LOCAL_OFF","geom","Offset","width","height","_size","Size","this","set","_tileFlags","Array","area","fill","addBody","x","y","index","removeBody","getBody","getFieldOfView","chebyshevRadius","origin","boundRect","Rectangle","mask","MaskRect","_quadrant","xDir","yDir","startX","startY","endDX","Math","min","max","endDY","startMapIndex","startMaskIndex","wedges","Number","POSITIVE_INFINITY","dy","yMapIndex","yMaskIndex","length","divYpos","divYneg","wedgeIndex","dx","mapIndex","maskIndex","slopeY","slopeX","setAt","cutWedge","low","high","splice","FieldOfViewMap","rect","initialValue","outsideValue","_rectangle","copyFrom","_mask","Mask","_outsideValue","toString","northWest","westX","northY","off","subtractOffset","getAt","get","containsOffset","value","forEach","cursor","callback","addOffset","size","_bits","ret","other","empty","__webpack_module_cache__","__webpack_require__","moduleId","exports","module","__webpack_modules__","call"],"mappings":"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","file":"the-field-1.0.6.min.js","sourcesContent":["import * as geom from './geom';\r\n\r\n// tslint:disable:no-bitwise\r\n\r\n/**\r\n * In the shadowcasting algorithm, each shadow is represented by a \"wedge\",\r\n * running from a \"low\" angle to a \"high\" angle.  The wedges are all stored in\r\n * a simple number array, with two numbers for each wedge.  These constants\r\n * (WEDGE_LOW and WEDGE_HIGH) help to identify which number is which.\r\n * WEDGE_COUNT is just how many numbers per wedge.\r\n */\r\nconst WEDGE_LOW = 0;\r\nconst WEDGE_HIGH = 1;\r\nconst WEDGE_COUNT = 2;\r\n\r\n/**\r\n * Bodies in this algorithm do not entirely fill their tiles.  This is\r\n * implemented by adjusting the angles of the shadows the bodies cast,\r\n * making the wedge very slightly narrower.  BODY_EPSILON represents the\r\n * amount of reduction on either side of the wedge.\r\n */\r\nconst BODY_EPSILON = 0.00001;\r\n\r\n/**\r\n * We avoid heap allocations during the core part of the algorithm by using this\r\n * preallocated offset object.\r\n */\r\nconst LOCAL_OFF = new geom.Offset();\r\n\r\n/**\r\n * For each number in the _tileFlags array, we store (1 << FLAGS_POW2) cells,\r\n * as bits where a true indicates the presence of a body.\r\n */\r\nconst FLAGS_POW2 = 5;\r\n\r\n/**\r\n * The FieldOFViewMap represents the map over which the field of view will be\r\n * computed.  It starts out empty.  You can add walls and bodies to it, and then\r\n * use getFieldOfView() to compute the field of view from a given point.\r\n */\r\nexport class FieldOfViewMap {\r\n    private readonly _size = new geom.Size();\r\n    private readonly _tileFlags: number[];\r\n\r\n    constructor(width: number, height: number) {\r\n        this._size.set(width, height);\r\n        this._tileFlags = new Array<number>((this._size.area >> FLAGS_POW2) + 1).fill(0);\r\n    }\r\n\r\n    // setup and maintenance\r\n\r\n    addBody(x: number, y: number) {\r\n        LOCAL_OFF.set(x, y);\r\n        const index = this._size.index(LOCAL_OFF);\r\n        this._tileFlags[index >> FLAGS_POW2] |= 1 << (index & ((1 << FLAGS_POW2) - 1));\r\n    }\r\n\r\n    removeBody(x: number, y: number) {\r\n        LOCAL_OFF.set(x, y);\r\n        const index = this._size.index(LOCAL_OFF);\r\n        this._tileFlags[index >> FLAGS_POW2] &= ~(1 << (index & ((1 << FLAGS_POW2) - 1)));\r\n    }\r\n\r\n    getBody(x: number, y: number) {\r\n        LOCAL_OFF.set(x, y);\r\n        const index = this._size.index(LOCAL_OFF);\r\n        return (this._tileFlags[index >> FLAGS_POW2] & (1 << (index & ((1 << FLAGS_POW2) - 1)))) !== 0;\r\n    }\r\n\r\n    // execution\r\n\r\n    /**\r\n     * Compute the field of view for a camera at the given tile.\r\n     * chebyshevRadius is the vision radius.  It uses chebyshev distance\r\n     * (https://en.wikipedia.org/wiki/Chebyshev_distance), which just means\r\n     * that the limit of vision in a large empty field will be square.\r\n     *\r\n     * This returns a MaskRect, which indicates which tiles are visible.\r\n     * maskRect.get(x, y) will return true for visible tiles.\r\n     */\r\n    getFieldOfView(x: number, y: number, chebyshevRadius: number): geom.MaskRect {\r\n        const origin = new geom.Offset(x, y);\r\n        const boundRect = new geom.Rectangle(\r\n            origin.x - chebyshevRadius, origin.y - chebyshevRadius,\r\n            chebyshevRadius * 2 + 1, chebyshevRadius * 2 + 1,\r\n        );\r\n        const mask = new geom.MaskRect(boundRect);\r\n        // the player can always see itself\r\n        mask.set(origin, true);\r\n        // the field is divided into quadrants\r\n        this._quadrant(mask, origin, chebyshevRadius, -1, -1);\r\n        this._quadrant(mask, origin, chebyshevRadius,  1, -1);\r\n        this._quadrant(mask, origin, chebyshevRadius, -1,  1);\r\n        this._quadrant(mask, origin, chebyshevRadius,  1,  1);\r\n        return mask;\r\n    }\r\n\r\n    private _quadrant(mask: geom.MaskRect, origin: geom.OffsetLike, chebyshevRadius: number,\r\n                      xDir: number, yDir: number) {\r\n        const {x: startX, y: startY} = origin;\r\n        const endDX = (Math.min(Math.max(startX + xDir * (chebyshevRadius + 1),\r\n                                         -1), this._size.width) - startX) * xDir;\r\n        const endDY = (Math.min(Math.max(startY + yDir * (chebyshevRadius + 1),\r\n                                         -1), this._size.height) - startY) * yDir;\r\n        if (endDX < 0 || endDY < 0) {\r\n            // the origin is outside of the map\r\n            return;\r\n        }\r\n        const startMapIndex = this._size.index(origin);\r\n        const startMaskIndex = mask.index(origin);\r\n        // Initial wedge is from slope zero to slope infinity (i.e. the whole quadrant)\r\n        const wedges = [0, Number.POSITIVE_INFINITY];\r\n        // X += Y must be written as X = X + Y, in order not to trigger deoptimization due to\r\n        // http://stackoverflow.com/questions/34595356/what-does-compound-let-const-assignment-mean\r\n        for (let dy = 0, yMapIndex = startMapIndex, yMaskIndex = startMaskIndex;\r\n             dy !== endDY && wedges.length > 0;\r\n             dy ++, yMapIndex = yMapIndex + yDir * this._size.width, yMaskIndex = yMaskIndex + yDir * mask.width\r\n        ) {\r\n            const divYpos = 1 / (dy + 0.5);\r\n            const divYneg = dy === 0 ? Number.POSITIVE_INFINITY : 1 / (dy - 0.5);\r\n            let wedgeIndex = 0;\r\n            // X += Y must be written as X = X + Y, in order not to trigger deoptimization due to\r\n            // http://stackoverflow.com/questions/34595356/what-does-compound-let-const-assignment-mean\r\n            for (let dx = 0, mapIndex = yMapIndex, maskIndex = yMaskIndex,\r\n                 slopeY = -0.5 * divYpos, slopeX = 0.5 * divYneg;\r\n                 dx !== endDX && wedgeIndex !== wedges.length;\r\n                 dx ++, mapIndex = mapIndex + xDir, maskIndex = maskIndex + xDir,\r\n                 slopeY = slopeY + divYpos, slopeX = slopeX + divYneg\r\n            ) {\r\n                // the slopes of the four corners of this tile\r\n                // these are named as follows:\r\n                //   slopeY is the slope closest to the Y axis\r\n                //   slopeX is the slope closest to the X axis\r\n                // this is always true:\r\n                //   slopeY < slopeX\r\n                //\r\n                // O = origin, C = current\r\n                // +---+---+---+\r\n                // | O |   |   |\r\n                // +---+---+---X\r\n                // |   |   | C |\r\n                // +---+---Y---+\r\n\r\n                // advance the wedge index until this tile is not after the current wedge\r\n                while (slopeY >= wedges[wedgeIndex + WEDGE_HIGH]) {\r\n                    // X += Y must be written as X = X + Y, in order not to trigger deoptimization due to\r\n                    // http://stackoverflow.com/questions/34595356/what-does-compound-let-const-assignment-mean\r\n                    wedgeIndex = wedgeIndex + WEDGE_COUNT;\r\n                    if (wedgeIndex >= wedges.length) {\r\n                        break;\r\n                    }\r\n                }\r\n                if (wedgeIndex >= wedges.length) {\r\n                    break;\r\n                }\r\n\r\n                // if the current wedge is after this tile, move on\r\n                if (slopeX <= wedges[wedgeIndex + WEDGE_LOW]) {\r\n                    continue;\r\n                }\r\n\r\n                // we can see this tile\r\n                mask.setAt(maskIndex, true);\r\n\r\n                // const/let must be at the top of a block, in order not to trigger deoptimization due to\r\n                // https://github.com/nodejs/node/issues/9729\r\n                {\r\n                    const body = (dx !== 0 || dy !== 0)\r\n                        && (this._tileFlags[mapIndex >> FLAGS_POW2]\r\n                            & (1 << (mapIndex & ((1 << FLAGS_POW2) - 1)))) !== 0;\r\n                    if (body) {\r\n                        wedgeIndex = cutWedge(wedges, wedgeIndex,\r\n                            slopeY + BODY_EPSILON, slopeX - BODY_EPSILON);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * This function cuts a range of angles out of the wedge array.\r\n */\r\nfunction cutWedge(wedges: number[], wedgeIndex: number, low: number, high: number): number {\r\n    for (; ; ) {\r\n        if (wedgeIndex === wedges.length) {\r\n            return wedgeIndex;\r\n        }\r\n        if (low <= wedges[wedgeIndex + WEDGE_HIGH]) {\r\n            break;\r\n        }\r\n        // This next line is to cover a hypothetical edge case, where two slopes\r\n        // are not the same, but are within the BODY_EPSILON distance.  That\r\n        // would be due to either floating point error or due to a very large\r\n        // field radius.  Either way I haven't been able to construct a test\r\n        // case for it.\r\n        wedgeIndex += WEDGE_COUNT;\r\n    }\r\n    if (low <= wedges[wedgeIndex + WEDGE_LOW]) {\r\n        if (high >= wedges[wedgeIndex + WEDGE_HIGH]) {\r\n            // wedge is entirely occluded, remove it\r\n            wedges.splice(wedgeIndex, WEDGE_COUNT);\r\n            // now looking at the next wedge (or past the end)\r\n            return cutWedge(wedges, wedgeIndex, low, high);\r\n        } else if (high >= wedges[wedgeIndex + WEDGE_LOW]) {\r\n            // low part of wedge is occluded, trim it\r\n            wedges[wedgeIndex + WEDGE_LOW] = high;\r\n            // still looking at the same wedge\r\n        } else {\r\n            // this cut doesn't reach the current wedge\r\n        }\r\n    } else if (high >= wedges[wedgeIndex + WEDGE_HIGH]) {\r\n        // high part of wedge is occluded, trim it\r\n        wedges[wedgeIndex + WEDGE_HIGH] = low;\r\n        // move on to the next wedge\r\n        wedgeIndex += WEDGE_COUNT;\r\n        return cutWedge(wedges, wedgeIndex, low, high);\r\n    } else {\r\n        // middle part of wedge is occluded, split it\r\n        wedges.splice(wedgeIndex, 0, wedges[wedgeIndex + WEDGE_LOW], low);\r\n        wedgeIndex += WEDGE_COUNT;\r\n        wedges[wedgeIndex + WEDGE_LOW] = high;\r\n        // now looking at the second wedge of the split\r\n    }\r\n    return wedgeIndex;\r\n}\r\n","export * from './offset';\r\nexport * from './size';\r\nexport * from './rectangle';\r\nexport * from './mask';\r\nexport * from './mask-rect';\r\n","import * as geom from '.';\r\n\r\nconst LOCAL_OFF = new geom.Offset();\r\n\r\nexport class MaskRect implements geom.RectangleLike {\r\n    private readonly _rectangle = new geom.Rectangle();\r\n    private readonly _mask: geom.Mask;\r\n    private readonly _outsideValue: boolean;\r\n\r\n    constructor(rect: geom.RectangleLike, initialValue = false, outsideValue = false) {\r\n        this._rectangle.copyFrom(rect);\r\n        this._mask = new geom.Mask(rect, initialValue);\r\n        this._outsideValue = outsideValue;\r\n    }\r\n\r\n    // accessors\r\n\r\n    toString() {\r\n        return `${this._rectangle.northWest}/${this._outsideValue}\\n${this._mask}`;\r\n    }\r\n\r\n    get westX() {\r\n        return this._rectangle.westX;\r\n    }\r\n\r\n    get northY() {\r\n        return this._rectangle.northY;\r\n    }\r\n\r\n    get width() {\r\n        return this._rectangle.width;\r\n    }\r\n\r\n    get height() {\r\n        return this._rectangle.height;\r\n    }\r\n\r\n    index(off: geom.OffsetLike) {\r\n        return this._mask.index(LOCAL_OFF.copyFrom(off).subtractOffset(this._rectangle.northWest));\r\n    }\r\n\r\n    getAt(index: number) {\r\n        return this._mask.getAt(index);\r\n    }\r\n\r\n    get(x: number, y: number) {\r\n        LOCAL_OFF.set(x, y);\r\n        if (!this._rectangle.containsOffset(LOCAL_OFF)) {\r\n            return this._outsideValue;\r\n        }\r\n        return this._mask.get(LOCAL_OFF.subtractOffset(this._rectangle.northWest));\r\n    }\r\n    // mutators\r\n\r\n    setAt(index: number, value: boolean) {\r\n        this._mask.setAt(index, value);\r\n        return this;\r\n    }\r\n\r\n    set(off: geom.OffsetLike, value: boolean) {\r\n        this._mask.set(LOCAL_OFF.copyFrom(off).subtractOffset(this._rectangle.northWest), value);\r\n        return this;\r\n    }\r\n\r\n    // utilities\r\n\r\n    forEach(cursor: geom.Offset, callback: (cursor: geom.Offset, value: boolean) => void) {\r\n        this._mask.forEach(cursor, (off, value) => {\r\n            callback(off.addOffset(this._rectangle.northWest), value);\r\n        });\r\n    }\r\n}\r\n","import * as geom from '.';\r\n\r\nexport class Mask implements geom.SizeLike {\r\n    private readonly _size = new geom.Size();\r\n    private readonly _bits: boolean[];\r\n    // TODO consider Uint8Array for bits\r\n\r\n    constructor(size: geom.SizeLike, initialValue = false) {\r\n        this._size.copyFrom(size);\r\n        this._bits = new Array<boolean>(this._size.area).fill(initialValue);\r\n    }\r\n\r\n    // accessors\r\n\r\n    toString() {\r\n        let ret = '';\r\n        const off = new geom.Offset();\r\n        for (let y = 0; y < this._size.height; y ++) {\r\n            for (let x = 0; x < this._size.width; x ++) {\r\n                off.set(x, y);\r\n                ret += this.get(off.set(x, y)) ? '☑' : '☐';\r\n            }\r\n            ret += '\\n';\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    get width() {\r\n        return this._size.width;\r\n    }\r\n\r\n    get height() {\r\n        return this._size.height;\r\n    }\r\n\r\n    index(off: geom.OffsetLike) {\r\n        return this._size.index(off);\r\n    }\r\n\r\n    getAt(index: number) {\r\n        return this._bits[index];\r\n    }\r\n\r\n    get(off: geom.OffsetLike) {\r\n        return this.getAt(this.index(off));\r\n    }\r\n\r\n    // mutators\r\n\r\n    setAt(index: number, value: boolean) {\r\n        this._bits[index] = value;\r\n        return this;\r\n    }\r\n\r\n    set(off: geom.OffsetLike, value: boolean) {\r\n        return this.setAt(this.index(off), value);\r\n    }\r\n\r\n    // utilities\r\n\r\n    forEach(cursor: geom.Offset, callback: (cursor: geom.Offset, value: boolean) => void) {\r\n        let index = 0;\r\n        this._size.forEach(cursor, (off) => {\r\n            callback(off, this._bits[index]);\r\n            index ++;\r\n        });\r\n    }\r\n}\r\n","export interface OffsetLike {\r\n    readonly x: number;\r\n    readonly y: number;\r\n}\r\n\r\nexport class Offset implements OffsetLike {\r\n    x: number;\r\n    y: number;\r\n\r\n    constructor();\r\n    constructor(x: number, y: number);\r\n    constructor(x?: number, y?: number) {\r\n        if (typeof x === 'undefined') {\r\n            x = 0;\r\n        }\r\n        if (typeof y === 'undefined') {\r\n            y = 0;\r\n        }\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n\r\n    toString() {\r\n        return `(${this.x},${this.y})`;\r\n    }\r\n\r\n    // mutators\r\n\r\n    set(x: number, y: number) {\r\n        this.x = x;\r\n        this.y = y;\r\n        return this;\r\n    }\r\n\r\n    copyFrom(other: OffsetLike) {\r\n        this.x = other.x;\r\n        this.y = other.y;\r\n        return this;\r\n    }\r\n\r\n    addOffset(off: OffsetLike) {\r\n        this.x += off.x;\r\n        this.y += off.y;\r\n        return this;\r\n    }\r\n\r\n    subtractOffset(off: OffsetLike) {\r\n        this.x -= off.x;\r\n        this.y -= off.y;\r\n        return this;\r\n    }\r\n}\r\n","import * as geom from '.';\r\n\r\nexport interface RectangleLike extends geom.SizeLike {\r\n    readonly westX: number;\r\n    readonly northY: number;\r\n}\r\n\r\nconst LOCAL_OFF = new geom.Offset();\r\n\r\nexport class Rectangle implements RectangleLike, geom.SizeLike {\r\n    northWest: geom.Offset;\r\n    size: geom.Size;\r\n\r\n    constructor();\r\n    constructor(westX: number, northY: number, width: number, height: number);\r\n    constructor(westX?: number, northY?: number, width?: number, height?: number) {\r\n        if (typeof westX === 'undefined') {\r\n            westX = 0;\r\n        }\r\n        if (typeof northY === 'undefined') {\r\n            northY = 0;\r\n        }\r\n        if (typeof width === 'undefined') {\r\n            width = 0;\r\n        }\r\n        if (typeof height === 'undefined') {\r\n            height = 0;\r\n        }\r\n        this.northWest = new geom.Offset(westX, northY);\r\n        this.size = new geom.Size(width, height);\r\n    }\r\n\r\n    // accessors\r\n\r\n    toString() {\r\n        return `(${this.westX},${this.northY} ${this.width}x${this.height})`;\r\n    }\r\n\r\n    get northY() {\r\n        return this.northWest.y;\r\n    }\r\n\r\n    get southY() {\r\n        return this.northWest.y + this.size.height - 1;\r\n    }\r\n\r\n    get westX() {\r\n        return this.northWest.x;\r\n    }\r\n\r\n    get eastX() {\r\n        return this.northWest.x + this.size.width - 1;\r\n    }\r\n\r\n    get width() {\r\n        return this.size.width;\r\n    }\r\n\r\n    get height() {\r\n        return this.size.height;\r\n    }\r\n\r\n    get empty() {\r\n        return this.size.empty;\r\n    }\r\n\r\n    get area() {\r\n        return this.size.area;\r\n    }\r\n\r\n    // mutators\r\n\r\n    copyFrom(other: RectangleLike) {\r\n        this.northWest.set(other.westX, other.northY);\r\n        this.size.set(other.width, other.height);\r\n        return this;\r\n    }\r\n\r\n    // utilities\r\n\r\n    containsOffset(off: geom.OffsetLike) {\r\n        return this.size.containsOffset(LOCAL_OFF.copyFrom(off).subtractOffset(this.northWest));\r\n    }\r\n\r\n    index(off: geom.OffsetLike) {\r\n        return this.size.index(LOCAL_OFF.copyFrom(off).subtractOffset(this.northWest));\r\n    }\r\n}\r\n","import * as geom from '.';\r\n\r\nexport interface SizeLike {\r\n    readonly width: number;\r\n    readonly height: number;\r\n}\r\n\r\nexport class Size implements SizeLike {\r\n    width: number;\r\n    height: number;\r\n\r\n    constructor();\r\n    constructor(width: number, height: number);\r\n    constructor(width?: number, height?: number) {\r\n        if (typeof width === 'undefined') {\r\n            width = 0;\r\n        }\r\n        if (typeof height === 'undefined') {\r\n            height = 0;\r\n        }\r\n        this.width = width;\r\n        this.height = height;\r\n    }\r\n\r\n    // accessors\r\n\r\n    toString() {\r\n        return `(${this.width}x${this.height})`;\r\n    }\r\n\r\n    get empty() {\r\n        return this.width === 0 || this.height === 0;\r\n    }\r\n\r\n    get area() {\r\n        return this.width * this.height;\r\n    }\r\n\r\n    // mutators\r\n\r\n    set(width: number, height: number) {\r\n        this.width = width;\r\n        this.height = height;\r\n        return this;\r\n    }\r\n\r\n    copyFrom(other: SizeLike) {\r\n        this.width = other.width;\r\n        this.height = other.height;\r\n        return this;\r\n    }\r\n\r\n    // utilities\r\n\r\n    containsOffset(off: geom.OffsetLike) {\r\n        return off.x >= 0 && off.y >= 0 && off.x < this.width && off.y < this.height;\r\n    }\r\n\r\n    index(off: geom.OffsetLike) {\r\n        return off.y * this.width + off.x;\r\n    }\r\n\r\n    forEach(cursor: geom.Offset, callback: (offset: geom.Offset) => void) {\r\n        for (let dy = 0; dy < this.height; dy ++) {\r\n            for (let dx = 0; dx < this.width; dx ++) {\r\n                cursor.x = dx;\r\n                cursor.y = dy;\r\n                callback(cursor);\r\n            }\r\n        }\r\n    }\r\n}\r\n","/*\r\n *  TheField\r\n *  github.com/sbj42/the-field\r\n *  James Clark\r\n *  Licensed under the MIT license.\r\n */\r\n\r\nexport {FieldOfViewMap} from './field-of-view';\r\nexport {MaskRect} from './geom';\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\nreturn __webpack_require__(607);\n"],"sourceRoot":""}