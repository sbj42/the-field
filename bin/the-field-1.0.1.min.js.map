{"version":3,"sources":["webpack://TheField/webpack/bootstrap","webpack://TheField/./src/geom/index.ts","webpack://TheField/./src/geom/mask-rect.ts","webpack://TheField/./src/geom/mask.ts","webpack://TheField/./src/geom/rectangle.ts","webpack://TheField/./src/geom/size.ts","webpack://TheField/./src/geom/offset.ts","webpack://TheField/./src/field-of-view.ts","webpack://TheField/./src/index.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","__export","geom","LOCAL_OFF","Offset","MaskRect","rect","initialValue","outsideValue","this","_rectangle","Rectangle","copyFrom","_mask","Mask","_outsideValue","toString","northWest","westX","northY","width","height","index","off","subtractOffset","getAt","x","y","set","containsOffset","setAt","forEach","cursor","callback","_this","addOffset","size","_size","Size","_bits","Array","area","fill","ret","empty","other","dy","dx","WEDGE_LOW","WEDGE_HIGH","WEDGE_COUNT","FLAGS_POW2","FieldOfViewMap","_tileFlags","addBody","removeBody","getBody","getFieldOfView","chebyshevRadius","origin","boundRect","mask","_quadrant","xDir","yDir","startX","startY","endDX","Math","min","max","endDY","startMapIndex","startMaskIndex","wedges","Number","POSITIVE_INFINITY","yMapIndex","yMaskIndex","length","divYpos","divYneg","wedgeIndex","mapIndex","maskIndex","slopeY","slopeX","cutWedge","low","high","splice","field_of_view_1","geom_1"],"mappings":"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","file":"the-field-1.0.1.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/bin/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 7);\n","export * from './offset';\r\nexport * from './size';\r\nexport * from './rectangle';\r\nexport * from './mask';\r\nexport * from './mask-rect';\r\n","import * as geom from '.';\r\n\r\nconst LOCAL_OFF = new geom.Offset();\r\n\r\nexport class MaskRect implements geom.RectangleLike {\r\n    private readonly _rectangle = new geom.Rectangle();\r\n    private readonly _mask: geom.Mask;\r\n    private readonly _outsideValue: boolean;\r\n\r\n    constructor(rect: geom.RectangleLike, initialValue = false, outsideValue = false) {\r\n        this._rectangle.copyFrom(rect);\r\n        this._mask = new geom.Mask(rect, initialValue);\r\n        this._outsideValue = outsideValue;\r\n    }\r\n\r\n    // accessors\r\n\r\n    toString() {\r\n        return `${this._rectangle.northWest}/${this._outsideValue}\\n${this._mask}`;\r\n    }\r\n\r\n    get westX() {\r\n        return this._rectangle.westX;\r\n    }\r\n\r\n    get northY() {\r\n        return this._rectangle.northY;\r\n    }\r\n\r\n    get width() {\r\n        return this._rectangle.width;\r\n    }\r\n\r\n    get height() {\r\n        return this._rectangle.height;\r\n    }\r\n\r\n    index(off: geom.OffsetLike) {\r\n        return this._mask.index(LOCAL_OFF.copyFrom(off).subtractOffset(this._rectangle.northWest));\r\n    }\r\n\r\n    getAt(index: number) {\r\n        return this._mask.getAt(index);\r\n    }\r\n\r\n    get(x: number, y: number) {\r\n        LOCAL_OFF.set(x, y);\r\n        if (!this._rectangle.containsOffset(LOCAL_OFF)) {\r\n            return this._outsideValue;\r\n        }\r\n        return this._mask.get(LOCAL_OFF.subtractOffset(this._rectangle.northWest));\r\n    }\r\n    // mutators\r\n\r\n    setAt(index: number, value: boolean) {\r\n        this._mask.setAt(index, value);\r\n        return this;\r\n    }\r\n\r\n    set(off: geom.OffsetLike, value: boolean) {\r\n        this._mask.set(LOCAL_OFF.copyFrom(off).subtractOffset(this._rectangle.northWest), value);\r\n        return this;\r\n    }\r\n\r\n    // utilities\r\n\r\n    forEach(cursor: geom.Offset, callback: (cursor: geom.Offset, value: boolean) => void) {\r\n        this._mask.forEach(cursor, (off, value) => {\r\n            callback(off.addOffset(this._rectangle.northWest), value);\r\n        });\r\n    }\r\n}\r\n","import * as geom from '.';\r\n\r\nexport class Mask implements geom.SizeLike {\r\n    private readonly _size = new geom.Size();\r\n    private readonly _bits: boolean[];\r\n    // TODO consider Uint8Array for bits\r\n\r\n    constructor(size: geom.SizeLike, initialValue = false) {\r\n        this._size.copyFrom(size);\r\n        this._bits = new Array<boolean>(this._size.area).fill(initialValue);\r\n    }\r\n\r\n    // accessors\r\n\r\n    toString() {\r\n        let ret = '';\r\n        const off = new geom.Offset();\r\n        for (let y = 0; y < this._size.height; y ++) {\r\n            for (let x = 0; x < this._size.width; x ++) {\r\n                off.set(x, y);\r\n                ret += this.get(off.set(x, y)) ? '☑' : '☐';\r\n            }\r\n            ret += '\\n';\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    get width() {\r\n        return this._size.width;\r\n    }\r\n\r\n    get height() {\r\n        return this._size.height;\r\n    }\r\n\r\n    index(off: geom.OffsetLike) {\r\n        return this._size.index(off);\r\n    }\r\n\r\n    getAt(index: number) {\r\n        return this._bits[index];\r\n    }\r\n\r\n    get(off: geom.OffsetLike) {\r\n        return this.getAt(this.index(off));\r\n    }\r\n\r\n    // mutators\r\n\r\n    setAt(index: number, value: boolean) {\r\n        this._bits[index] = value;\r\n        return this;\r\n    }\r\n\r\n    set(off: geom.OffsetLike, value: boolean) {\r\n        return this.setAt(this.index(off), value);\r\n    }\r\n\r\n    // utilities\r\n\r\n    forEach(cursor: geom.Offset, callback: (cursor: geom.Offset, value: boolean) => void) {\r\n        let index = 0;\r\n        this._size.forEach(cursor, (off) => {\r\n            callback(off, this._bits[index]);\r\n            index ++;\r\n        });\r\n    }\r\n}\r\n","import * as geom from '.';\r\n\r\nexport interface RectangleLike extends geom.SizeLike {\r\n    readonly westX: number;\r\n    readonly northY: number;\r\n}\r\n\r\nconst LOCAL_OFF = new geom.Offset();\r\n\r\nexport class Rectangle implements RectangleLike, geom.SizeLike {\r\n    northWest: geom.Offset;\r\n    size: geom.Size;\r\n\r\n    constructor();\r\n    constructor(westX: number, northY: number, width: number, height: number);\r\n    constructor(westX?: number, northY?: number, width?: number, height?: number) {\r\n        if (typeof westX === 'undefined') {\r\n            westX = 0;\r\n        }\r\n        if (typeof northY === 'undefined') {\r\n            northY = 0;\r\n        }\r\n        if (typeof width === 'undefined') {\r\n            width = 0;\r\n        }\r\n        if (typeof height === 'undefined') {\r\n            height = 0;\r\n        }\r\n        this.northWest = new geom.Offset(westX, northY);\r\n        this.size = new geom.Size(width, height);\r\n    }\r\n\r\n    // accessors\r\n\r\n    toString() {\r\n        return `(${this.westX},${this.northY} ${this.width}x${this.height})`;\r\n    }\r\n\r\n    get northY() {\r\n        return this.northWest.y;\r\n    }\r\n\r\n    get southY() {\r\n        return this.northWest.y + this.size.height - 1;\r\n    }\r\n\r\n    get westX() {\r\n        return this.northWest.x;\r\n    }\r\n\r\n    get eastX() {\r\n        return this.northWest.x + this.size.width - 1;\r\n    }\r\n\r\n    get width() {\r\n        return this.size.width;\r\n    }\r\n\r\n    get height() {\r\n        return this.size.height;\r\n    }\r\n\r\n    get empty() {\r\n        return this.size.empty;\r\n    }\r\n\r\n    get area() {\r\n        return this.size.area;\r\n    }\r\n\r\n    // mutators\r\n\r\n    copyFrom(other: RectangleLike) {\r\n        this.northWest.set(other.westX, other.northY);\r\n        this.size.set(other.width, other.height);\r\n        return this;\r\n    }\r\n\r\n    // utilities\r\n\r\n    containsOffset(off: geom.OffsetLike) {\r\n        return this.size.containsOffset(LOCAL_OFF.copyFrom(off).subtractOffset(this.northWest));\r\n    }\r\n\r\n    index(off: geom.OffsetLike) {\r\n        return this.size.index(LOCAL_OFF.copyFrom(off).subtractOffset(this.northWest));\r\n    }\r\n}\r\n","import * as geom from '.';\r\n\r\nexport interface SizeLike {\r\n    readonly width: number;\r\n    readonly height: number;\r\n}\r\n\r\nexport class Size implements SizeLike {\r\n    width: number;\r\n    height: number;\r\n\r\n    constructor();\r\n    constructor(width: number, height: number);\r\n    constructor(width?: number, height?: number) {\r\n        if (typeof width === 'undefined') {\r\n            width = 0;\r\n        }\r\n        if (typeof height === 'undefined') {\r\n            height = 0;\r\n        }\r\n        this.width = width;\r\n        this.height = height;\r\n    }\r\n\r\n    // accessors\r\n\r\n    toString() {\r\n        return `(${this.width}x${this.height})`;\r\n    }\r\n\r\n    get empty() {\r\n        return this.width === 0 || this.height === 0;\r\n    }\r\n\r\n    get area() {\r\n        return this.width * this.height;\r\n    }\r\n\r\n    // mutators\r\n\r\n    set(width: number, height: number) {\r\n        this.width = width;\r\n        this.height = height;\r\n        return this;\r\n    }\r\n\r\n    copyFrom(other: SizeLike) {\r\n        this.width = other.width;\r\n        this.height = other.height;\r\n        return this;\r\n    }\r\n\r\n    // utilities\r\n\r\n    containsOffset(off: geom.OffsetLike) {\r\n        return off.x >= 0 && off.y >= 0 && off.x < this.width && off.y < this.height;\r\n    }\r\n\r\n    index(off: geom.OffsetLike) {\r\n        return off.y * this.width + off.x;\r\n    }\r\n\r\n    forEach(cursor: geom.Offset, callback: (offset: geom.Offset) => void) {\r\n        for (let dy = 0; dy < this.height; dy ++) {\r\n            for (let dx = 0; dx < this.width; dx ++) {\r\n                cursor.x = dx;\r\n                cursor.y = dy;\r\n                callback(cursor);\r\n            }\r\n        }\r\n    }\r\n}\r\n","export interface OffsetLike {\r\n    readonly x: number;\r\n    readonly y: number;\r\n}\r\n\r\nexport class Offset implements OffsetLike {\r\n    x: number;\r\n    y: number;\r\n\r\n    constructor();\r\n    constructor(x: number, y: number);\r\n    constructor(x?: number, y?: number) {\r\n        if (typeof x === 'undefined') {\r\n            x = 0;\r\n        }\r\n        if (typeof y === 'undefined') {\r\n            y = 0;\r\n        }\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n\r\n    toString() {\r\n        return `(${this.x},${this.y})`;\r\n    }\r\n\r\n    // mutators\r\n\r\n    set(x: number, y: number) {\r\n        this.x = x;\r\n        this.y = y;\r\n        return this;\r\n    }\r\n\r\n    copyFrom(other: OffsetLike) {\r\n        this.x = other.x;\r\n        this.y = other.y;\r\n        return this;\r\n    }\r\n\r\n    addOffset(off: OffsetLike) {\r\n        this.x += off.x;\r\n        this.y += off.y;\r\n        return this;\r\n    }\r\n\r\n    subtractOffset(off: OffsetLike) {\r\n        this.x -= off.x;\r\n        this.y -= off.y;\r\n        return this;\r\n    }\r\n}\r\n","import * as geom from './geom';\r\n\r\n// tslint:disable:no-bitwise\r\n\r\n/**\r\n * In the shadowcasting algorithm, each shadow is represented by a \"wedge\",\r\n * running from a \"low\" angle to a \"high\" angle.  The wedges are all stored in\r\n * a simple number array, with two numbers for each wedge.  These constants\r\n * (WEDGE_LOW and WEDGE_HIGH) help to identify which number is which.\r\n * WEDGE_COUNT is just how many numbers per wedge.\r\n */\r\nconst WEDGE_LOW = 0;\r\nconst WEDGE_HIGH = 1;\r\nconst WEDGE_COUNT = 2;\r\n\r\n/**\r\n * Bodies in this algorithm do not entirely fill their tiles.  This is\r\n * implemented by adjusting the angles of the shadows the bodies cast,\r\n * making the wedge very slightly narrower.  BODY_EPSILON represents the\r\n * amount of reduction on either side of the wedge.\r\n */\r\nconst BODY_EPSILON = 0.00001;\r\n\r\n/**\r\n * We avoid heap allocations during the core part of the algorithm by using this\r\n * preallocated offset object.\r\n */\r\nconst LOCAL_OFF = new geom.Offset();\r\n\r\n/**\r\n * For each number in the _tileFlags array, we store (1 << FLAGS_POW2) cells,\r\n * as bits where a true indicates the presence of a body.\r\n */\r\nconst FLAGS_POW2 = 5;\r\n\r\n/**\r\n * The FieldOFViewMap represents the map over which the field of view will be\r\n * computed.  It starts out empty.  You can add walls and bodies to it, and then\r\n * use getFieldOfView() to compute the field of view from a given point.\r\n */\r\nexport class FieldOfViewMap {\r\n    private readonly _size = new geom.Size();\r\n    private readonly _tileFlags: number[];\r\n\r\n    constructor(width: number, height: number) {\r\n        this._size.set(width, height);\r\n        this._tileFlags = new Array<number>((this._size.area >> FLAGS_POW2) + 1).fill(0);\r\n    }\r\n\r\n    // setup and maintenance\r\n\r\n    addBody(x: number, y: number) {\r\n        LOCAL_OFF.set(x, y);\r\n        const index = this._size.index(LOCAL_OFF);\r\n        this._tileFlags[index >> FLAGS_POW2] |= 1 << (index & ((1 << FLAGS_POW2) - 1));\r\n    }\r\n\r\n    removeBody(x: number, y: number) {\r\n        LOCAL_OFF.set(x, y);\r\n        const index = this._size.index(LOCAL_OFF);\r\n        this._tileFlags[index >> FLAGS_POW2] &= ~(1 << (index & ((1 << FLAGS_POW2) - 1)));\r\n    }\r\n\r\n    getBody(x: number, y: number) {\r\n        LOCAL_OFF.set(x, y);\r\n        const index = this._size.index(LOCAL_OFF);\r\n        return (this._tileFlags[index >> FLAGS_POW2] & (1 << (index & ((1 << FLAGS_POW2) - 1)))) !== 0;\r\n    }\r\n\r\n    // execution\r\n\r\n    /**\r\n     * Compute the field of view for a camera at the given tile.\r\n     * chebyshevRadius is the vision radius.  It uses chebyshev distance\r\n     * (https://en.wikipedia.org/wiki/Chebyshev_distance), which just means\r\n     * that the limit of vision in a large empty field will be square.\r\n     *\r\n     * This returns a MaskRect, which indicates which tiles are visible.\r\n     * maskRect.get(x, y) will return true for visible tiles.\r\n     */\r\n    getFieldOfView(x: number, y: number, chebyshevRadius: number): geom.MaskRect {\r\n        const origin = new geom.Offset(x, y);\r\n        const boundRect = new geom.Rectangle(\r\n            origin.x - chebyshevRadius, origin.y - chebyshevRadius,\r\n            chebyshevRadius * 2 + 1, chebyshevRadius * 2 + 1,\r\n        );\r\n        const mask = new geom.MaskRect(boundRect);\r\n        // the player can always see itself\r\n        mask.set(origin, true);\r\n        // the field is divided into quadrants\r\n        this._quadrant(mask, origin, chebyshevRadius, -1, -1);\r\n        this._quadrant(mask, origin, chebyshevRadius,  1, -1);\r\n        this._quadrant(mask, origin, chebyshevRadius, -1,  1);\r\n        this._quadrant(mask, origin, chebyshevRadius,  1,  1);\r\n        return mask;\r\n    }\r\n\r\n    private _quadrant(mask: geom.MaskRect, origin: geom.OffsetLike, chebyshevRadius: number,\r\n                      xDir: number, yDir: number) {\r\n        const {x: startX, y: startY} = origin;\r\n        const endDX = (Math.min(Math.max(startX + xDir * (chebyshevRadius + 1),\r\n                                         -1), this._size.width) - startX) * xDir;\r\n        const endDY = (Math.min(Math.max(startY + yDir * (chebyshevRadius + 1),\r\n                                         -1), this._size.height) - startY) * yDir;\r\n        if (endDX < 0 || endDY < 0) {\r\n            // the origin is outside of the map\r\n            return;\r\n        }\r\n        const startMapIndex = this._size.index(origin);\r\n        const startMaskIndex = mask.index(origin);\r\n        // Initial wedge is from slope zero to slope infinity (i.e. the whole quadrant)\r\n        const wedges = [0, Number.POSITIVE_INFINITY];\r\n        // X += Y must be written as X = X + Y, in order not to trigger deoptimization due to\r\n        // http://stackoverflow.com/questions/34595356/what-does-compound-let-const-assignment-mean\r\n        for (let dy = 0, yMapIndex = startMapIndex, yMaskIndex = startMaskIndex;\r\n             dy !== endDY && wedges.length > 0;\r\n             dy ++, yMapIndex = yMapIndex + yDir * this._size.width, yMaskIndex = yMaskIndex + yDir * mask.width\r\n        ) {\r\n            const divYpos = 1 / (dy + 0.5);\r\n            const divYneg = dy === 0 ? Number.POSITIVE_INFINITY : 1 / (dy - 0.5);\r\n            let wedgeIndex = 0;\r\n            // X += Y must be written as X = X + Y, in order not to trigger deoptimization due to\r\n            // http://stackoverflow.com/questions/34595356/what-does-compound-let-const-assignment-mean\r\n            for (let dx = 0, mapIndex = yMapIndex, maskIndex = yMaskIndex,\r\n                 slopeY = -0.5 * divYpos, slopeX = 0.5 * divYneg;\r\n                 dx !== endDX && wedgeIndex !== wedges.length;\r\n                 dx ++, mapIndex = mapIndex + xDir, maskIndex = maskIndex + xDir,\r\n                 slopeY = slopeY + divYpos, slopeX = slopeX + divYneg\r\n            ) {\r\n                // the slopes of the four corners of this tile\r\n                // these are named as follows:\r\n                //   slopeY is the slope closest to the Y axis\r\n                //   slopeX is the slope closest to the X axis\r\n                // this is always true:\r\n                //   slopeY < slopeX\r\n                //\r\n                // O = origin, C = current\r\n                // +---+---+---+\r\n                // | O |   |   |\r\n                // +---+---+---X\r\n                // |   |   | C |\r\n                // +---+---Y---+\r\n\r\n                // advance the wedge index until this tile is not after the current wedge\r\n                while (slopeY >= wedges[wedgeIndex + WEDGE_HIGH]) {\r\n                    // X += Y must be written as X = X + Y, in order not to trigger deoptimization due to\r\n                    // http://stackoverflow.com/questions/34595356/what-does-compound-let-const-assignment-mean\r\n                    wedgeIndex = wedgeIndex + WEDGE_COUNT;\r\n                    if (wedgeIndex >= wedges.length) {\r\n                        break;\r\n                    }\r\n                }\r\n                if (wedgeIndex >= wedges.length) {\r\n                    break;\r\n                }\r\n\r\n                // if the current wedge is after this tile, move on\r\n                if (slopeX <= wedges[wedgeIndex + WEDGE_LOW]) {\r\n                    continue;\r\n                }\r\n\r\n                // we can see this tile\r\n                mask.setAt(maskIndex, true);\r\n\r\n                // const/let must be at the top of a block, in order not to trigger deoptimization due to\r\n                // https://github.com/nodejs/node/issues/9729\r\n                {\r\n                    const body = (dx !== 0 || dy !== 0)\r\n                        && (this._tileFlags[mapIndex >> FLAGS_POW2]\r\n                            & (1 << (mapIndex & ((1 << FLAGS_POW2) - 1)))) !== 0;\r\n                    if (body) {\r\n                        wedgeIndex = cutWedge(wedges, wedgeIndex,\r\n                            slopeY + BODY_EPSILON, slopeX - BODY_EPSILON);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * This function cuts a range of angles out of the wedge array.\r\n */\r\nfunction cutWedge(wedges: number[], wedgeIndex: number, low: number, high: number): number {\r\n    for (; ; ) {\r\n        if (wedgeIndex === wedges.length) {\r\n            return wedgeIndex;\r\n        }\r\n        if (low <= wedges[wedgeIndex + WEDGE_HIGH]) {\r\n            break;\r\n        }\r\n        // This next line is to cover a hypothetical edge case, where two slopes\r\n        // are not the same, but are within the BODY_EPSILON distance.  That\r\n        // would be due to either floating point error or due to a very large\r\n        // field radius.  Either way I haven't been able to construct a test\r\n        // case for it.\r\n        wedgeIndex += WEDGE_COUNT;\r\n    }\r\n    if (low <= wedges[wedgeIndex + WEDGE_LOW]) {\r\n        if (high >= wedges[wedgeIndex + WEDGE_HIGH]) {\r\n            // wedge is entirely occluded, remove it\r\n            wedges.splice(wedgeIndex, WEDGE_COUNT);\r\n            // now looking at the next wedge (or past the end)\r\n            return cutWedge(wedges, wedgeIndex, low, high);\r\n        } else if (high >= wedges[wedgeIndex + WEDGE_LOW]) {\r\n            // low part of wedge is occluded, trim it\r\n            wedges[wedgeIndex + WEDGE_LOW] = high;\r\n            // still looking at the same wedge\r\n        } else {\r\n            // this cut doesn't reach the current wedge\r\n        }\r\n    } else if (high >= wedges[wedgeIndex + WEDGE_HIGH]) {\r\n        // high part of wedge is occluded, trim it\r\n        wedges[wedgeIndex + WEDGE_HIGH] = low;\r\n        // move on to the next wedge\r\n        wedgeIndex += WEDGE_COUNT;\r\n        return cutWedge(wedges, wedgeIndex, low, high);\r\n    } else {\r\n        // middle part of wedge is occluded, split it\r\n        wedges.splice(wedgeIndex, 0, wedges[wedgeIndex + WEDGE_LOW], low);\r\n        wedgeIndex += WEDGE_COUNT;\r\n        wedges[wedgeIndex + WEDGE_LOW] = high;\r\n        // now looking at the second wedge of the split\r\n    }\r\n    return wedgeIndex;\r\n}\r\n","/*\r\n *  TheField\r\n *  github.com/sbj42/the-field\r\n *  James Clark\r\n *  Licensed under the MIT license.\r\n */\r\n\r\nexport {FieldOfViewMap} from './field-of-view';\r\nexport {MaskRect} from './geom';\r\n"],"sourceRoot":""}